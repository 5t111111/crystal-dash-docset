<!DOCTYPE html><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta charset="utf-8"/>
  <meta id="repository-name" content="github.com/manastech/crystal"/>
  <link href="css/style.css" rel="stylesheet" type="text/css"/>
  
  <a class="dashingAutolink" name="autolink-2428"></a><a class="dashAnchor" name="//apple_ref/cpp/Class/JSON"></a><title>JSON</title>
</head>
<body>



<div id="main-content">
<h1 class="type-name">

  <span class="kind">module</span> JSON

</h1>





  <h2>Overview</h2>

  <p>The JSON module allows parsing and generating <a href="http://json.org/" target="_blank">JSON</a> documents.</p>

<h3>Parsing and generating with <code><a href="JSON.html#mapping%28properties%2Cstrict%3Dfalse%29-macro">JSON#mapping</a></code>
</h3>

<p>Use <code><a href="JSON.html#mapping%28properties%2Cstrict%3Dfalse%29-macro">JSON#mapping</a></code> to define how an object is mapped to JSON, making it
the recommended easy, type-safe and efficient option for parsing and generating
JSON. Refer to that module&#39;s documentation to learn about it.</p>

<h3>Parsing with <code><a href="JSON.html#parse%28input%3AString%7CIO%29%3AType-class-method">JSON#parse</a></code>
</h3>

<p><code><a href="JSON.html#parse%28input%3AString%7CIO%29%3AType-class-method">JSON#parse</a></code> will return a <code><a href="JSON/Type.html">Type</a></code>, which is a union of all possible JSON types,
making it mandatory to use casts or type checks to deal with parsed values:</p>

<pre><code><span class="k">require</span> <span class="s">&#34;json&#34;</span>

value <span class="o">=</span> <span class="t">JSON</span>.parse(<span class="s">&#34;[1, 2, 3]&#34;</span>) <span class="c">#:: JSON::Type</span>
<span class="c"># value[0] # compile-error, compiler can&#39;t know that value is indeed an Array</span>
array <span class="o">=</span> value <span class="k">as</span> <span class="t">Array</span>
array[<span class="n">0</span>] <span class="c">#:: JSON::Type</span>
(array[<span class="n">0</span>] <span class="k">as</span> <span class="t">Int</span>) <span class="o">+</span> <span class="n">10</span> <span class="c">#=&gt; 11</span></code></pre>

<p>The above becomes tedious quickly, but can be useful for handling dynamic JSON content.</p>

<h3>Generating with <code><a href="JSON/Builder.html">JSON::Builder</a></code>
</h3>

<p>Use <code>JSON::Buidler</code> to generate JSON on the fly by directly emitting data
to an <code><a href="IO.html">IO</a></code>.</p>

<h3>Generating with <code>to_json</code>
</h3>

<p><code>to_json</code> and <code>to_json(<a href="IO.html">IO</a>)</code> methods are provided for primitive types, but you
need to define <code>to_json(<a href="IO.html">IO</a>)</code> for custom objects, either manually or using
<code><a href="JSON.html#mapping%28properties%2Cstrict%3Dfalse%29-macro">JSON#mapping</a></code>.</p>














  <h2>Defined in:</h2>
  
    
      <a href="https://github.com/manastech/crystal/blob/b3b1223108806f31fdb29cca6110a5d11d82f504/src/json/any.cr" target="_blank">json/any.cr</a>
    
    <br/>
  
    
      <a href="https://github.com/manastech/crystal/blob/b3b1223108806f31fdb29cca6110a5d11d82f504/src/json/json.cr" target="_blank">json/json.cr</a>
    
    <br/>
  
    
      <a href="https://github.com/manastech/crystal/blob/b3b1223108806f31fdb29cca6110a5d11d82f504/src/json/mapping.cr" target="_blank">json/mapping.cr</a>
    
    <br/>
  





  <h2>Class Method Summary</h2>
  <ul class="list-summary">
    
      <li class="entry-summary">
        <a href="#parse%28input%3AString%7CIO%29%3AType-class-method" class="signature"><strong>.parse</strong>(input : String | IO) : Type</a>
        
          <div class="summary"><p>Parses a JSON document.</p></div>
        
      </li>
    
  </ul>





  <h2>Macro Summary</h2>
  <ul class="list-summary">
    
      <li class="entry-summary">
        <a href="#mapping%28properties%2Cstrict%3Dfalse%29-macro" class="signature"><strong>mapping</strong>(properties, strict = false)</a>
        
          <div class="summary"><p>The <code><a href="JSON.html">JSON</a>.mapping</code> macro defines how an object is mapped to JSON.</p></div>
        
      </li>
    
  </ul>



<div class="methods-inherited">
  
</div>


  <h2>Class Method Detail</h2>
  
    <div class="entry-detail" id="parse(input:String|IO):Type-class-method">
      <a class="dashingAutolink" name="autolink-2426"></a><a class="dashAnchor" name="//apple_ref/cpp/Method/def%20self.parse%28input%20%3A%20String%20%7C%20IO%29%20%3A%20Type"></a><div class="signature">
        
        def self.<strong>parse</strong>(input : <a href="String.html">String</a> | <a href="IO.html">IO</a>) : <a href="JSON/Type.html">Type</a>

        
      </div>
      
        <div class="doc"><p>Parses a JSON document.</p></div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/manastech/crystal/blob/b3b1223108806f31fdb29cca6110a5d11d82f504/src/json/json.cr#L51" target="_blank">View source</a>]
        
      </div>
    </div>
  





  <h2>Macro Detail</h2>
  
    <div class="entry-detail" id="mapping(properties,strict=false)-macro">
      <a class="dashingAutolink" name="autolink-2427"></a><a class="dashAnchor" name="//apple_ref/cpp/Method/macro%20mapping%28properties%2C%20strict%20%3D%20false%29"></a><div class="signature">
        
        macro <strong>mapping</strong>(properties, strict = false)

        
      </div>
      
        <div class="doc">
<p>The <code><a href="JSON.html">JSON</a>.mapping</code> macro defines how an object is mapped to JSON.</p>

<h3>Example</h3>

<pre><code><span class="k">require</span> <span class="s">&#34;json&#34;</span>

<span class="k">class</span> <span class="t">Location</span>
  <span class="t">JSON</span>.mapping({
    lat: <span class="t">Float64</span>,
    lng: <span class="t">Float64</span>,
  })
<span class="k">end</span>

<span class="k">class</span> <span class="t">House</span>
  <span class="t">JSON</span>.mapping({
    address: <span class="t">String</span>,
    location: {<span class="k">type</span>: <span class="t">Location</span>, nilable: <span class="n">true</span>},
  })
<span class="k">end</span>

house <span class="o">=</span> <span class="t">House</span>.from_json(<span class="s">%({&#34;address&#34;: &#34;Crystal Road 1234&#34;, &#34;location&#34;: {&#34;lat&#34;: 12.3, &#34;lng&#34;: 34.5}})</span>)
house.address  <span class="c">#=&gt; &#34;Crystal Road 1234&#34;</span>
house.location <span class="c">#=&gt; #&amp;lt;Location:0x10cd93d80 @lat=12.3, @lng=34.5&gt;</span>
house.to_json  <span class="c">#=&gt; %({&#34;address&#34;:&#34;Crystal Road 1234&#34;,&#34;location&#34;:{&#34;lat&#34;:12.3,&#34;lng&#34;:34.5}})</span></code></pre>

<h3>Usage</h3>

<p><code><a href="JSON.html">JSON</a>.mapping</code> must receive a hash literal whose keys will define Crystal properties.</p>

<p>The value of each key can be a single type (not a union type). Primitive types (numbers, string, boolean and nil)
are supported, as well as custom objects which use <code><a href="JSON.html">JSON</a>.mapping</code> or define a <code>new</code> method
that accepts a <code><a href="JSON/PullParser.html">JSON::PullParser</a></code> and returns an object from it.</p>

<p>The value can also be another hash literal with the following options:</p>

<ul>
<li>type: (required) the single type described above</li>
<li>key: the property name in the JSON document (as opposed to the property name in the Crystal code)</li>
<li>nilable: if true, the property can be <code><a href="Nil.html">Nil</a></code>
</li>
<li>emit_null: if true, emits a <code>null</code> value for nilable properties (by default nulls are not emitted)</li>
<li>converter: specify an alternate type for parsing and generation. The converter must define <code>from_json(<a href="JSON/PullParser.html">JSON::PullParser</a>)</code> and <code>to_json(value, <a href="IO.html">IO</a>)</code> as class methods.</li>
</ul>

<p>The mapping also automatically defines Crystal properties (getters and setters) for each
of the keys. It doesn&#39;t define a constructor accepting those arguments, but you can provide
an overload.</p>

<p>The macro basically defines a constructor accepting a <code><a href="JSON/PullParser.html">JSON::PullParser</a></code> that reads from
it and initializes this type&#39;s instance variables. It also defines a <code>to_json(<a href="IO.html">IO</a>)</code> method
by invoking <code>to_json(<a href="IO.html">IO</a>)</code> on each of the properties (unless a converter is specified, in
which case <code>to_json(value, <a href="IO.html">IO</a>)</code> is invoked).</p>

<p>If <code>strict</code> is true, unknown properties in the JSON
document will raise a parse exception. The default is <code>false</code>, so unknown properties
are silently ignored.</p>
</div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/manastech/crystal/blob/b3b1223108806f31fdb29cca6110a5d11d82f504/src/json/mapping.cr#L56" target="_blank">View source</a>]
        
      </div>
    </div>
  


</div>



</body></html>